name: Intune Configuration Policy Lifecycle

on:
  pull_request:
    types: [labeled]
    branches:
      - main

permissions:
  id-token: write
  contents: write
  pull-requests: write

jobs:

  determine-action:
    runs-on: ubuntu-latest
    environment: GraphApi
    outputs:
      action_type: ${{ steps.setaction.outputs.action_type }}
      target_env: ${{ steps.setaction.outputs.target_env }}

    steps:
      - id: setaction
        run: |
          case "${{ github.event.label.name }}" in
            import-policy)
              echo "action_type=import" >> $GITHUB_OUTPUT
              ;;
            promote-wave1)
              echo "action_type=promote" >> $GITHUB_OUTPUT
              echo "target_env=Wave1" >> $GITHUB_OUTPUT
              ;;
            promote-wave2)
              echo "action_type=promote" >> $GITHUB_OUTPUT
              echo "target_env=Wave2" >> $GITHUB_OUTPUT
              ;;
            promote-wave3)
              echo "action_type=promote" >> $GITHUB_OUTPUT
              echo "target_env=Wave3" >> $GITHUB_OUTPUT
              ;;
            promote-prod)
              echo "action_type=promote" >> $GITHUB_OUTPUT
              echo "target_env=Prod" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Unknown label"
              exit 1
              ;;
          esac

  validate:
    needs: determine-action
    runs-on: ubuntu-latest

    steps:
      - name: Validate Workflow Logic
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.pull_request.labels.map(l => l.name);
            const actionType = "${{ needs.determine-action.outputs.action_type }}";
            const targetEnv = "${{ needs.determine-action.outputs.target_env }}";

            const order = ["Wave1","Wave2","Wave3","Prod"];
            const labelMap = {
              Wave1: "promote-wave1",
              Wave2: "promote-wave2",
              Wave3: "promote-wave3",
              Prod: "promote-prod"
            };

            if (actionType === "promote") {

              if (!labels.includes("import-policy")) {
                core.setFailed("Policy must be imported before promotion.");
              }

              const currentIndex = order.indexOf(targetEnv);

              if (currentIndex > 0) {
                const previousLabel = labelMap[order[currentIndex - 1]];
                if (!labels.includes(previousLabel)) {
                  core.setFailed(`Cannot promote to ${targetEnv}. Missing ${previousLabel}.`);
                }
              }

              const waveLabels = Object.values(labelMap);
              const appliedWaveLabels = labels.filter(l => waveLabels.includes(l));

              if (appliedWaveLabels.length > 1) {
                core.setFailed("Only one promotion label allowed at a time.");
              }
            }

  deploy:
    needs: [determine-action, validate]
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-action.outputs.target_env }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          allow-no-subscriptions: true

      - name: Deploy Policy
        shell: pwsh
        run: |

          $base = "${{ github.event.pull_request.base.sha }}"
          $head = "${{ github.event.pull_request.head.sha }}"

          $changedFiles = git diff --name-only $base $head |
                          Where-Object { $_ -like "policies/*.json" }

          if (-not $changedFiles) {
              Write-Host "No policy changes detected."
              exit 0
          }

          Install-Module Microsoft.Graph.Authentication -Force -AllowClobber
          Install-Module Microsoft.Graph.Beta.DeviceManagement -Force -AllowClobber

          $GraphTokenResponse = az account get-access-token --resource https://graph.microsoft.com
          $GraphToken = ($GraphTokenResponse | ConvertFrom-Json).accessToken
          $SecureToken = ConvertTo-SecureString $GraphToken -AsPlainText -Force

          Connect-MgGraph -AccessToken $SecureToken

          foreach ($file in $changedFiles) {

              $json = Get-Content $file -Raw | ConvertFrom-Json
              $policyName = $json.name

              $existing = Invoke-MgGraphRequest `
                -Method GET `
                -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies?`$filter=name eq '$policyName'"

              if ($existing.value.Count -gt 0) {
                  $policyId = $existing.value[0].id
                  Invoke-MgGraphRequest `
                    -Method PATCH `
                    -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$policyId" `
                    -Body ($json | ConvertTo-Json -Depth 100)
              }
              else {
                  $created = Invoke-MgGraphRequest `
                    -Method POST `
                    -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies" `
                    -Body ($json | ConvertTo-Json -Depth 100)
                  $policyId = $created.id
              }

              if ("${{ needs.determine-action.outputs.action_type }}" -eq "import") {

                  # Remove assignments only
                  $assignments = Invoke-MgGraphRequest `
                    -Method GET `
                    -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$policyId/assignments"

                  foreach ($a in $assignments.value) {
                      Invoke-MgGraphRequest `
                        -Method DELETE `
                        -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$policyId/assignments/$($a.id)"
                  }

                  Write-Host "Policy imported with no assignments."
              }
              else {

                  $groupId = "${{ secrets.TARGET_GROUP_ID }}"

                  $assignmentBody = @{
                    assignments = @(
                      @{
                        target = @{
                          "@odata.type" = "#microsoft.graph.groupAssignmentTarget"
                          groupId = $groupId
                        }
                      }
                    )
                  }

                  Invoke-MgGraphRequest `
                    -Method POST `
                    -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$policyId/assign" `
                    -Body ($assignmentBody | ConvertTo-Json -Depth 10)

                  Write-Host "Policy promoted to group $groupId"
              }
          }

  auto-merge:
    needs: deploy
    if: needs.determine-action.outputs.target_env == 'Prod'
    runs-on: ubuntu-latest

    steps:
      - name: Enable Auto Merge
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          pull-request-number: ${{ github.event.pull_request.number }}
          merge-method: squash
