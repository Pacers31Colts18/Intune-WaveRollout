name: "Intune Policy Lifecycle"

on:
  pull_request:
    types: [opened, synchronize, labeled]
  workflow_dispatch:
  schedule:
    - cron: '0 3 * * *'

permissions:
  id-token: write
  contents: write
  pull-requests: write

jobs:

  # -------------------------
  # Import Policies
  # -------------------------
  import:
    runs-on: ubuntu-latest
    environment: Import
    outputs:
      policy_ids: ${{ steps.save_ids.outputs.policy_ids }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          allow-no-subscriptions: true

      - name: Import policies and capture IDs
        id: save_ids
        shell: pwsh
        run: |
          $stagingPath = "${{ github.workspace }}/staging.csv"
          if (-not (Test-Path $stagingPath)) { Write-Host "No staging.csv found"; exit 0 }

          $staging = Import-Csv $stagingPath
          $uniquePolicies = $staging.FileName | Sort-Object -Unique
          $policyIds = @{}

          $tokenResp = az account get-access-token --resource https://graph.microsoft.com
          $graphToken = ($tokenResp | ConvertFrom-Json).accessToken
          $secureToken = ConvertTo-SecureString $graphToken -AsPlainText -Force

          Install-Module Microsoft.Graph.Authentication -Force -AllowClobber
          Install-Module Microsoft.Graph.Beta.DeviceManagement -Force -AllowClobber
          Connect-MgGraph -AccessToken $secureToken

          foreach ($file in $uniquePolicies) {
              $policyName = $file.Replace(".json","")

              # Load the JSON policy file if it exists
              $jsonPath = "${{ github.workspace }}/policies/$file"
              if (Test-Path $jsonPath) {
                  $json = Get-Content $jsonPath -Raw | ConvertFrom-Json

                  # Remove read-only/system-managed properties
                  $json.PSObject.Properties.Remove('id')
                  $json.PSObject.Properties.Remove('createdDateTime')
                  $json.PSObject.Properties.Remove('lastModifiedDateTime')
                  $json.PSObject.Properties.Remove('version')
                  $json.PSObject.Properties.Remove('supportedScopeTags')
              } else {
                  $json = @{ name = $policyName; "@odata.type"="#microsoft.graph.deviceConfiguration" }
              }

              # Check if policy already exists
              $existing = Invoke-MgGraphRequest -Method GET -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies?`$filter=name eq '$policyName'"
              if ($existing.value.Count -gt 0) {
                  # PATCH existing policy
                  $policyId = $existing.value[0].id
                  Invoke-MgGraphRequest -Method PATCH -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$policyId" -Body ($json | ConvertTo-Json -Depth 100)
              } else {
                  # POST new policy
                  $created = Invoke-MgGraphRequest -Method POST -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies" -Body ($json | ConvertTo-Json -Depth 100)
                  $policyId = $created.id
              }

              $policyIds[$file] = $policyId
              Write-Host "Imported '$policyName' -> $policyId"
          }

          # Output the mapping for downstream jobs
          $jsonOutput = $policyIds | ConvertTo-Json -Compress
          echo "policy_ids=$jsonOutput" >> $GITHUB_OUTPUT

  # -------------------------
  # Apply Assignments
  # -------------------------
  assign:
    needs: import
    runs-on: ubuntu-latest
    environment: Wave
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          allow-no-subscriptions: true

      - name: Apply assignments from CSV
        shell: pwsh
        run: |
          $stagingPath = "${{ github.workspace }}/staging.csv"
          if (-not (Test-Path $stagingPath)) { Write-Host "No staging.csv found"; exit 0 }

          $deployments = Import-Csv $stagingPath
          $policyIds = ${{ fromJson(needs.import.outputs.policy_ids) }}

          $tokenResp = az account get-access-token --resource https://graph.microsoft.com
          $graphToken = ($tokenResp | ConvertFrom-Json).accessToken
          $secureToken = ConvertTo-SecureString $graphToken -AsPlainText -Force

          Install-Module Microsoft.Graph.Authentication -Force -AllowClobber
          Install-Module Microsoft.Graph.Beta.DeviceManagement -Force -AllowClobber
          Connect-MgGraph -AccessToken $secureToken

          foreach ($deploy in $deployments) {
              $file = $deploy.FileName
              if (-not $policyIds.ContainsKey($file)) { continue }
              $policyId = $policyIds[$file]

              $existingAssignments = Invoke-MgGraphRequest -Method GET -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$policyId/assignments"

              # Build assignment objects for each include group
              $includeGroups = $deploy.IncludeGroups -split ";" | Where-Object { $_ }
              $excludeGroups = $deploy.ExcludeGroups -split ";" | Where-Object { $_ }

              $assignmentsToApply = @()

              foreach ($g in $includeGroups) {
                  $assignment = @{
                      target = @{
                          "@odata.type" = "#microsoft.graph.groupAssignmentTarget"
                          groupId = $g
                      }
                  }
                  # apply filter if present
                  if ($deploy.Filter) {
                      $filter = Invoke-MgGraphRequest -Method GET -Uri "https://graph.microsoft.com/beta/deviceManagement/deviceConfigurationAssignmentFilters?`$filter=displayName eq '$($deploy.Filter)'"
                      if ($filter.value.Count -gt 0) {
                          $assignment.target.filterId = $filter.value[0].id
                          $assignment.target.filterType = $filter.value[0].deviceAndAppManagementAssignmentFilterType
                          $assignment.target.filterMode = $deploy.FilterMode
                      }
                  }
                  $assignmentsToApply += $assignment
              }

              # If All Devices or All Users is in includeGroups, remove previous assignments
              if ($includeGroups -contains ${{ secrets.ALLDEVICES_GROUP_ID }} -or $includeGroups -contains ${{ secrets.ALLUSERS_GROUP_ID }}) {
                  foreach ($a in $existingAssignments.value) {
                      Invoke-MgGraphRequest -Method DELETE -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$policyId/assignments/$($a.id)"
                  }
              }

              # Apply new assignments
              foreach ($a in $assignmentsToApply) {
                  Invoke-MgGraphRequest -Method POST -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$policyId/assign" -Body ($a | ConvertTo-Json -Depth 10)
              }

              # Apply exclude groups (always accumulate)
              foreach ($g in $excludeGroups) {
                  $assignment = @{
                      target = @{
                          "@odata.type" = "#microsoft.graph.groupAssignmentTarget"
                          groupId = $g
                      }
                      @{"exclude" = $true}
                  }
                  Invoke-MgGraphRequest -Method POST -Uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$policyId/assign" -Body ($assignment | ConvertTo-Json -Depth 10)
              }

              Write-Host "Applied assignments for '$file'"
